import { ConditionError } from '../../error/';

import { LexerToken, ParseTree } from '../';

/**
 * A recursive decent parser for a SQL condition (WHERE or ON).  This parser
 * takes in a set of tokens, as generated by the [[ConditionLexer.parse]]
 * method, and makes sure that the condition is valid.  If the condition
 * sentence does not match the condition grammer, an exception is raised.
 * Otherwise, a [[ParseTree]] is created.
 */
export class ConditionParser {
  /**
   * Parse the tokens return a [[ParseTree]].  The condition must follow the
   * following grammar.
   *
   * <pre>
   *   &lt;condition&gt;                ::= "{" &lt;comparison&gt; | &lt;null-comparison&gt; | &lt;in-comparison&gt; | &lt;logical-condition&gt; "}"
   *   &lt;comparison&gt;               ::= &lt;comparison-operator&gt; ":" "{" &lt;column&gt; ":" &lt;value&gt; "}"
   *   &lt;null-comparison&gt;          ::= &lt;null-comparison-operator&gt; ":" "{" &lt;column&gt; ":" &lt;nullable&gt; "}"
   *   &lt;in-comparison&gt;            ::= &lt;in-comparison-operator&gt; ":" "{" &lt;column&gt; ":" "[" &lt;value&gt; {"," &lt;value&gt;} "]" "}"
   *   &lt;logical-condition&gt;        ::= &lt;boolean-operator&gt; ":" "[" &lt;condition&gt; {"," &lt;condition&gt;} "]"
   *   &lt;comparison-operator&gt;      ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte" | "$like" | "$notlike"
   *   &lt;in-comparison-operator&gt;   ::= "$in" | "$notIn"
   *   &lt;null-comparison-operator&gt; ::= "$is" | "$isnt"
   *   &lt;boolean-operator&gt;         ::= "$and" | "$or"
   *   &lt;nullable&gt;                 ::= null | &lt;parameter&gt;
   *   &lt;value&gt;                    ::= &lt;parameter&gt; | &lt;column&gt; | &lt;number&gt;
   *   &lt;column&gt;                   ::= &lt;string&gt;
   *   &lt;parameter&gt;                ::= :&lt;string&gt;
   * </pre>
   *
   * @param tokens - An array of tokens, as created by the [[ConditionLexer]].parse
   * method.
   * @return - A parse tree.  Each node in the tree has a token and children
   * nodes.
   */
  parse(tokens: LexerToken[]): ParseTree {
    let tokenInd: number = 0;
    let token: LexerToken = tokens[tokenInd];
    let tree: ParseTree = null;
    let curNode: ParseTree = null;

    // Parse the program, and return the resulting parse tree.
    condition();

    if (token !== null)
      throw new ConditionError(errorString('EOL'));

    return tree;

    // <condition> ::= "{" <comparison> | <null-comparison> | <in-comparison> | <logical-condition> "}"
    function condition(): void {
      const pairParts = ['comparison-operator', 'null-comparison-operator', 'in-comparison-operator', 'boolean-operator'];

      charTerminal('{');

      if (!tokenIn(pairParts))
        throw new ConditionError(errorString('[' + pairParts.join(' | ') + ']'));

      if (token.type === 'comparison-operator')
        comparison();
      else if (token.type === 'null-comparison-operator')
        nullComparison();
      else if (token.type === 'in-comparison-operator')
        inComparison();
      else
        logicalCondition();

      charTerminal('}');
    }

    // <comparison> ::= <comparison-operator> ":" "{" <column> ":" <value> "}"
    function comparison(): void {
      comparisonOperator();
      charTerminal(':');
      charTerminal('{');
      column();
      charTerminal(':');
      value();
      charTerminal('}');
    }

    // <in-comparison> ::= <in-comparison-operator> ":" "{" <column> ":" "[" <value> {"," <value>} "]" "}"
    function inComparison(): void {
      inComparisonOperator();
      charTerminal(':');
      charTerminal('{');
      column();
      charTerminal(':');
      charTerminal('[');
      value();
      while (token.value === ',') {
        charTerminal(',');
        value();
      }
      charTerminal(']');
      charTerminal('}');
    }

    // <null-comparison> ::= <null-comparison-operator> ":" "{" <column> ":" <nullable> "}"
    function nullComparison(): void {
      nullComparisonOperator();
      charTerminal(':');
      charTerminal('{');
      column();
      charTerminal(':');
      nullable();
      charTerminal('}');
    }

    // <logical-condition> ::= <boolean-operator> ":" "[" <condition> {"," <condition>} "]"
    function logicalCondition(): void {
      booleanOperator();
      charTerminal(':');
      charTerminal('[');
      condition();
      // <boolean-operator> is preceded by an array of <condition>.  After adding each
      // <condition> node make the <boolean-operator> the current node.
      curNode = curNode.parent;
      while (token && token.value === ',') {
        charTerminal(',');
        condition();
        curNode = curNode.parent;
      }
      charTerminal(']');
    }

    // <comparison-operator> ::= "$eq" | "$neq" | "$lt" | "$lte" | "$gt" | "$gte"
    function comparisonOperator(): void {
      matchType('comparison-operator');
    }

    // <in-comparison-operator> ::= "$in" | "$notIn"
    function inComparisonOperator(): void {
      matchType('in-comparison-operator');
    }

    // <null-comparison-operator> ::= "$is" | "$isnt"
    function nullComparisonOperator(): void {
      matchType('null-comparison-operator');
    }

    // <boolean-operator> ::= "$and" | "$or"
    function booleanOperator(): void {
      matchType('boolean-operator');
    }

    // <nullable> ::= null | <parameter>
    function nullable(): void {
      const values = ['null', 'parameter'];

      if (!tokenIn(values))
        throw new ConditionError(errorString('[' + values.join(' | ') + ']'));

      if (token.type === 'null')
        nullTerminal();
      else
        parameter();
    }

    // <value> ::= <parameter> | <column> | <number>
    function value(): void {
      const values = ['parameter', 'column', 'number'];

      if (!tokenIn(values))
        throw new ConditionError(errorString('[' + values.join(' | ') + ']'));

      if (token.type === 'parameter')
        parameter();
      else if (token.type === 'column')
        column();
      else
        number();
    }

    // <parameter> ::= :<string>
    function parameter(): void {
      matchType('parameter');
    }

    // <column> ::= <string>
    function column(): void {
      matchType('column');
    }

    // Number terminal.
    function number(): void {
      matchType('number');
    }

    // Handles non-characters.  Verifies that the current token's type matches
    // the passed-in type.  If not, an exception is raised.  If so, the token is
    // advanced.
    function matchType(type: string): void {
      if (token === null || token.type !== type)
        throw new ConditionError(errorString(`<${type}>`));

      addNode();
      advance();
    }

    // Handles the basic character terminals, which aren't needed in the
    // resulting sentence/tree.  These are the basic terminals: "{", "}", "[",
    // "]", ":", ","
    function charTerminal(c: string): void {
      if (token === null || c !== token.value)
        throw new ConditionError(errorString(c));

      advance();
    }

    // Checks that the current token is a null terminal.
    function nullTerminal(): void {
      if (token === null || token.type !== 'null')
        throw new ConditionError(errorString('null'));

      addNode();
      advance();
    }

    // Move to the next token, or set token to null if the end of the sentence is
    // encountered.
    function advance(): void {
      if (tokenInd >= tokens.length)
        throw new ConditionError('Encountered the end of the sentence prematurely.');

      if (++tokenInd < tokens.length)
        token = tokens[tokenInd];
      else
        token = null;
    }

    // Check if the current token matches one of the types on toks.
    function tokenIn(tokTypes: string[]): boolean {
      return tokTypes.some(type => token.type === type);
    }

    // Helper to create an error string.
    function errorString(expected: string): string {
      const type  = token ? token.type  : 'EOL';
      const value = token ? token.value : 'EOL';

      return `At index ${tokenInd}.  Expected ${expected} but found type ` +
             `${type} with value ${value}.`;
    }

    // Helper function to add a node to the parse tree.
    function addNode(): void {
      const node = new ParseTree(curNode, token);

      // If there is no tree, this is the root node.
      if (tree === null) {
        tree = curNode = node;
        return;
      }

      // This node is a child of the current node.
      curNode.children.push(node);

      // If the current token is a non-terminal then make the new node the
      // current node.  The tree is structued with non-terminals having terminal
      // children.
      //        __$eq__
      //       /       \
      //    'name'   ':name'
      if (!token.terminal)
        curNode = node;
    }
  }
}

