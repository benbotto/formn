Get rid of empty lines with spaces.
It would be nice to provide a decompile method in the ConditionCompiler.  This could take a condition object and build a new condition object using a ColumnLookup instance (e.g. replace all column names).  That could be useful in APIs because the programmer could provide a limited list of filterable properties with sane names (i.e. the API consumer wouldn't need to know about internal aliases).
The npm run build script should exclude specs, so there needs to be two tsconfig files.
There's a to-do note in column.decorator.ts.  The dataType isn't going to work for non-primitives (like related entities).  Maybe just use the type.name and map them on demand (i.e. store the TS type in the column, not the db type).  Seems like trying to map conversions there isn't going to work because the mapping is different for different db flavors (e.g. boolean->bit, tinyint, etc.).  Whenever this is fixed be sure to fix the documentation in column-meta-options.ts.
A thought I had is that each from/join could add the alias to an object, so above there would be
   {
     u: {id: 'u.id', first: 'u.first', ...},
     pn: {id: 'pn.id', ...}
   }
 Then select could take a function: select(({u}) => [u.id, u.first]).  It wouldn't help with type safety, though, because TS doesn't support variadic generics.

Here's what I'm thinking for the condition builder, set as a to-do item in ndm.
 
const cb = new ConditionBuilder();

cb.and(
  cb.eq('u.name', 'Ben'),
  cb.gt('u.dob', '2014-01-01')
)

Returns a 

class ParameterizedCondition {
  condition: object;
  params: object;
}

It would be nice if empty conditions returned empty strings, but it's kind of complex to implement.  Eg {} = '', {$and: []} = '', {$in: {col: []}} = ''

To add composite support:
  Schema.
  From (when creating joins).
  Select (in execute).

For MSSQL support:
  MSSQLExecuter.
  Test fully-qualified table names with schema.
  Test fully-qualified table names in FROM.
  Test fully-qualified table names in insert.

For transactions:
  Each method in Executor needs an optional connection parameter, which is a
  connection acquired from the pool (pool.getConnection()/conn.release()).

  The execute method in Query then needs an optional connection parameter.

