Get rid of empty lines with spaces.
TableMetadata needs an optional schema.
If properties are going to be throughout (rather than column names), then all the properties are going to have to be swapped out in the condition objects.
It would be nice to provide a decompile method in the ConditionCompiler.  This could take a condition object and build a new condition object using a ColumnLookup instance (e.g. replace all column names).  That could be useful in APIs because the programmer could provide a limited list of filterable properties with sane names (i.e. the API consumer wouldn't need to know about internal aliases).
The npm run build script should exclude specs, so there needs to be two tsconfig files.
There's a to-do note in column.decorator.ts.  The dataType isn't going to work for non-primitives (like related entities).  Maybe just use the type.name and map them on demand (i.e. store the TS type in the column, not the db type).  Seems like trying to map conversions there isn't going to work because the mapping is different for different db flavors (e.g. boolean->bit, tinyint, etc.).  Whenever this is fixed be sure to fix the documentation in column-meta-options.ts.
This syntax seems okay for selecting.
  dc.from(User, 'u')
    .innerJoin(PhoneNumber, 'pn', 'u.phoneNumbers', cond?, params?)
    .select();
 I thought I had is that each from/join could add the alias to an object, so above there would be
   {
     u: {id: 'u.id', first: 'u.first', ...},
     pn: {id: 'pn.id', ...}
   }
 Then select could take a function: select(({u}) => [u.id, u.first]).  It wouldn't help with type safety, though, because TS doesn't support variadic generics.

Here's what I'm thinking for the condition builder, set as a to-do item in ndm.
 
const cb = new ConditionBuilder();

cb.and(
  cb.eq('u.name', 'Ben'),
  cb.gt('u.dob', '2014-01-01')
)

Returns a 

class ParameterizedCondition {
  condition: object;
  params: object;
}

It would be nice if empty conditions returned empty strings, but it's kind of complex to implement.  Eg {} = '', {$and: []} = '', {$in: {col: []}} = ''
